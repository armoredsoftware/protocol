2 way comm guide:

A and B want to communicate. It is unknown if A will begin establishment with B or vise-versa. 


	Let's say A's protocol sends a message to B, and complimentarily, B's protocol receives a message from A. As stated, it is non-deterministic who will get to their CreateChannel statement first. Therefore we implement the following communication protocol.
Note: At this point, each party creates a channel whether or not B's protocol involves talking with A. Upon A's request, a channel will be created. B's protocol just won't use it so the channel is kind of worthless. 

1. Start up: 
	When A and B start to exist, they both start a thread serving on an agreed upon port (3000). At this point we also assume that if A wishes to talk to B, A knows where B is. That is to say, A knows B's IP address and domain ID (for VChan). The purpose of this service is for each party to establish a channel (preferably VChan) with the other upon request.

	Let's say A get's to its communication-with-B statement before B get's to his/hers. 

A first checks to see if it already has a channel with B. Channel already existing is perfectly possible when reaching a CreateChannel command since B could have gotten to its communication code first and requested that A establish communication with it and hence created a channel. If A already has a channel established with B, no channel is actually created with the CreateChannel command (One can think of the CreateChannel command as a create-if-needed command). 
NOTE: While it is possible for qA to communicate with B without A doing a createChannel, it's really stupid. If B doesn't get to it's CreateChannel-with-A command first, A will get stuck. If you need to use a channel, always create a channel. But it should be noted that it's possible to get away with not creating a channel and using it with unpredictable results. Perhaps this can be partially caught with the type checker (partially due to allowing creating channels with variables. 
	If A finds that a channel with B does not yet exist, A sends a communication request to B (recall everyone serves on an agreed upon port as soon as they are conjured into existance). A sends in this request all the information B would need to establish a channel (Note: so in theory and with perhaps slight tweaking it would be possible for only one party to know how to reach the other and then establish a channel). B then, after receiving this request, puts a lock on the list of channels it currently has. This lock is needed to ensure that duplicate channels are not created. Without the lock, A and B could send requests to each other "about the same time" for the same channel and each end up add two channels for the other party (each responding to a connection request and a create of their own). WITH the lock, B receives the request, puts a lock on the list, then checks if it is still necessary to create a channel. If so, we begin channel establishment:
       Let's go back in time just a little. When A found it neccessary to create a channel with B and thus send the comm request, A created a VChan channel that receives from the ID known of the other party. Now, it's perfectly possible that A and B are in different xen instances. Therefore it's perfectly possible that A starts listing to a local ID that is of the afar party B's ID and just so happens to be an actual local ID. Therefore, in our comm request sent to B, we include a nonce. (NOTE: This 'protocol' is based on the assumption that we have no idea if the person we want to talk to is in the same xen instance as us not. IRL, perhaps we do know.) B receives the comm request from A (including the nonce) and sends the nonce to the ID given in the request. If A does not receive the nonce (within a reasonable yet to be determined time--should be pretty short) then we know we can't communicate over VChan and must establish an http channel. NOTE: Since we only start listening on VChan channels when we want to communicate with a party that has that ID, if we ever receive a nonce that is unnexpected and incorrect, we know we can immediately stop listening on that VChan channel and close it (Additional note: it does not mean we can permanently close it. It is perfectly possible that we receive an erroneous nonce from an ID we are listening to, but later, we actually do want to communicate with that party that sent us the weird nonce. For instance, if A wants to talk with B and at a later point A_Neighbor, it's possible that A_Neighbor and B have the same IDs given that B is in a different xen instance. Here is a little more detail:
	It is a 'rare' occurance that we will receive erroneous nonces over VChan since the following pre-conditions would need to be met:
		A and B want to talk to each other and live in separate xen instances.
		There is another party in A's xen instance say, A_Neighbor, who has received a request from someone who has the same ID as A, and therefore sends the nonce out to A
		Additionally, A_Neighbor has the same ID as B. Whamo. Confusion.

NOTE: This does not prove identity whatsover! After this channel is established, identity must be proven using a TPM. In the above senario perhaps A is malicious. A receives a weird nonce and instead of ignoring it, sends it off to its buddy who lives in B's xen instance. The buddy ('A_Buddy') could then perhaps change it's ID to what is expected by B (A_buddy's malicious friend A's ID) and then send the nonce to B (this would, of course, have to happen quite quickly before B times out the VChan comm). B sees that this entity correctly knew the nonce.. Therefore it is vital to prove Identity after the channel has been established. If identity fails then perhaps this is exactly the case where malicious A has a buddy in B's neighborhood. B may then wish to hightail it out of that xen instance and/or reAttempt channel establishment with A (perhaps only http this time or after 'x' attempts at channel establishment since there is no reason why this facade attack couldn't be repeated 'x' number of times. Besides, what are the odds you hop to a xen instance that contains the entity with whom you are trying to communicate.) 
	So why bother with VChan at all? Why not always just use http? It is my understanding that using VChan for communication provides different trust properties than Http. For instance, being able to talk on Vchan means we know the entity is a neighbor. Maybe we want to then know more about what that guy is doing. After all, it's a nice neighborhood and if this person is cooking meth, maybe we want to change neighborhoods (xen instances, I've been watching a lot of Breaking Bad recently). However it must also be noted that just because we are not talking over VChan does not mean that the other party is NOT a neighbor. i.e. VChan -> Neighbor, but Neighbor !-> VChan. Therefore we must be careful what we deduce from channel establishment. 


	Anyway, back to where we were. Let's recap. A and B want to talk. A gets to its comm code first, checks to see if a channel exists, sees that no channel yet exists (A of course has a lock on the list of established channels. whoops, introduced something new in a recap), and sends a comm request to B containing A's info and a nonce. A starts listening on a Vchan channel using the ID of B--you know, just in case they can wisper instead of yell (Vchan vs http). A then waits.... Meanwhile....
B receives this comm request and puts a lock on its list of established channels. B checks if it needs to establish the channel, seeing that it does need to create a channel, the first thing B tries is to send a nonce out on the VChan channel listed in the request (by server_init, then client init with ID). Now, at this point if A receives the nonce it sent out, A 'knows' it can establish the channel over VChan. This is communicated to B by replying with nonce + 1 over the vChan channel. Now on the B side, if B receives the nonce + 1, B continues channel establishment using VChan (actually pretty much done). Now let's say we can't do VChan. i.e. A and B are in different xen instances. i.e. A doesn't receive the nonce back within reasonable time and B doesn't receive nonce + 1 within reasonable time. Upon this 'timeout' let's  look at each party's actions. 'A' closes its vchan channel since it is no longer needed for this channel (and another createChannel command or response to comm request may need to create the vchan channel again). Similarly, B closes up its Vchan stuff, then simply (LOL simply...) waits for a port request to come in. So now A now knows it must communicate with B using http. Therefore A goes ahead and looks at its already used ports in the channel list and comes up with a port num be3r not already in use (probably max + 1) and sends a port request to B containing this port number. This port number acts at two things. 1. As the port B knows it can reach A at. and 2. B will use it as a suggestion to serve on its own (hey, you gotta start somewhere). This port request from A to B happens over that same pre-known ip/port that everyone runs this "comm protocol" on. B receives this port request taht includes a port suggestion. B, still having a lock on the channels, checks to see if it has any existing connections using that port listed in the request. B finds an unused port (perhaps the suggestion, perhaps not), begins listening on it and sends it back to A THIS TIME on the port A specified.
       Both parties can now release the lock on their respective channel lists (after adding the newly created channels of course). 

	So there's a shared channel, now what? Associated with each established channel are TMVar [Armored] and TMVar (). Both are necessary. While reading, always take the TMVar () first, then the TMVar []. () indicates whether or not the list is empty. That is why we block on that first. We want someone to be able to add to the message queue while we wait for it not to be empty. Everytime a message is added to the queue, TMVar () is 'put'. Then after every read, we check the size of the list. If it is empty, we take () and wait for someone (a writer) to put it back. () acts as a lock for readers as well since we want to 'consume' each message. ie not read it twice.
	Note: having all this in TMVars means that we can fork each send to do it's thing and continue on to do some computation (note only send. we want to ensure we have the channel before continuing (createChannel) and computation following a receive (likely) depends on what was received i.e. will add a variable binding to the state we depend on in future computation.  

Problems: 
- Note this implementation locks all the channels upon each request. Therefore it becomes difficult to get much done if a party is bombarded with channel requests (attack!). Maybe give favor to protocol execution over channel responses and explicitly change threads after a channel establishment 

- Each port request results in a channel being created --good or bad it happens. Maybe have a name server and only establish channels between entities known there?
	
