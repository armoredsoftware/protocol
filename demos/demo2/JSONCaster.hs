{-# LANGUAGE OverloadedStrings, TemplateHaskell #-}
module JSONCaster where

import Demo2Shared as D2
import Data.Aeson
import qualified Data.Aeson as DA
import Data.Aeson.TH
import Data.Map
import Data.Text
import Data.Word
import qualified Data.ByteString.Lazy as LB
import qualified Data.ByteString.Lazy.Char8 as LBC
import qualified Data.ByteString as B


$(deriveJSON defaultOptions ''EvidenceDescriptor)
$(deriveJSON defaultOptions ''DesiredEvidence)
$(deriveJSON defaultOptions ''EvidencePiece)
$(deriveJSON defaultOptions ''Quote)
$(deriveJSON defaultOptions ''Evidence)
$(deriveJSON defaultOptions ''Request)
$(deriveJSON defaultOptions ''Response)



{--To properly (successfully) convert to a JSON object the data object must have record
syntax. Therefore, these are simply wrappers of the existing data types with the 
exception of EvidencePieceW which contains a more 'JSON-friendly' internal data type 
--}

{--
data DesiredEvidenceW = DEW {desiredEvidence :: DesiredEvidence} deriving (Show)
data EvidenceDescriptorW = EDW {evidenceDescriptor :: EvidenceDescriptor} deriving ( Show)
data EvidencePieceW = EPW {evidencePiece2 :: EvidencePiece2} deriving (Show)
--}


--main= putStrLn (show (toJSON D0))

{-| 
  This data type is 'JSON-ready' since Word8 is already an instance of To(From)JSON whereas
ByteString is not.
-}
{--
data EvidencePiece2 = M02 [Word8]|
                      M12 [Word8] |
                      M22 [Word8] deriving (Show)
--}
{--
-- |Conversion from an EvidencePiece to a 'JSON-ready' data type (EvidencePiece2)
createEvidencePiece2 :: EvidencePiece -> EvidencePiece2
createEvidencePiece2 (M0 rep) = M02 (B.unpack rep)
createEvidencePiece2 (M1 rep) = M12 (B.unpack rep)
createEvidencePiece2 (M2 rep) = M22 (B.unpack rep)

-- |A function to convert back to an EvidencePiece
ep2ToEp :: EvidencePiece2 -> EvidencePiece
ep2ToEp (M02 rep) = M0 (B.pack rep) 
ep2ToEp (M12 rep) = M1 (B.pack rep)
ep2ToEp (M22 rep) = M2 (B.pack rep)
--}

{- autogenerated code. This generated code has been saved to JSONCaster_splices.hs 
   for reference.
   Genereated by: ghc -ddump-splices JSONCaster.hs 2> JSONCaster_splices.hs-}


{--
data Testdata = Dat {field :: String} deriving (Show)

$(deriveJSON defaultOptions ''Testdata)
--(deriveJSON defaultOptions ''M0Rep)
testE2 =createEvidencePiece2 (M0 (Prelude.head (LB.toChunks (LBC.pack "This is the content."))))
testED = D0
--}

jsonEncode :: (ToJSON a) => a -> LB.ByteString
jsonEncode = DA.encode

jsonDecode :: (FromJSON a) =>  LB.ByteString -> Maybe a
jsonDecode= DA.decode

